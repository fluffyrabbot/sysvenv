#!/usr/bin/env python3
"""
sysvenv - Two-Tier Python Package System Manager

Manages user-level Python virtual environment with automatic snapshots,
history tracking, and easy undo/rollback capabilities.
"""

import argparse
import fcntl
import json
import os
import shutil
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
import venv


# ============================================================================
# Constants & Paths
# ============================================================================

HOME = Path.home()
SYSVENV_ROOT = HOME / ".local" / "python-packages"
VENV_PATH = SYSVENV_ROOT / "venv"
HISTORY_PATH = SYSVENV_ROOT / "history"
SNAPSHOTS_PATH = SYSVENV_ROOT / "snapshots"
CONFIG_PATH = SYSVENV_ROOT / "config.toml"
LOCK_FILE = SYSVENV_ROOT / ".sysvenv.lock"

# Reserved snapshot names that cannot be used
RESERVED_SNAPSHOT_NAMES = {'baseline'}
MAX_SNAPSHOT_NAME_LENGTH = 64

DEFAULT_CONFIG = """[history]
max_entries = 100
auto_snapshot = true
show_diff_after_install = true

[snapshots]
auto_baseline = true

[ui]
color = true
verbose = false
"""


# ============================================================================
# Colors & Output
# ============================================================================

class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    GRAY = "\033[90m"


def color_enabled() -> bool:
    """Check if color output should be enabled"""
    return sys.stdout.isatty() and os.getenv("NO_COLOR") is None


def cprint(text: str, color: str = "", bold: bool = False):
    """Print colored text if color is enabled"""
    if color_enabled():
        style = Colors.BOLD if bold else ""
        print(f"{style}{color}{text}{Colors.RESET}")
    else:
        print(text)


def success(text: str):
    cprint(f"âœ“ {text}", Colors.GREEN)


def error(text: str):
    cprint(f"âœ— {text}", Colors.RED, bold=True)


def warning(text: str):
    cprint(f"âš  {text}", Colors.YELLOW)


def info(text: str):
    cprint(f"â„¹ {text}", Colors.BLUE)


def heading(text: str):
    cprint(f"\n{text}", Colors.CYAN, bold=True)


# ============================================================================
# Helpers
# ============================================================================

def run_command(cmd: List[str], capture: bool = True, check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command with better error handling"""
    try:
        if capture:
            return subprocess.run(cmd, capture_output=True, text=True, check=check, timeout=300)
        else:
            return subprocess.run(cmd, check=check, timeout=300)
    except subprocess.TimeoutExpired:
        error(f"Command timed out after 5 minutes: {' '.join(cmd)}")
        error("This might indicate network issues or a very large package")
        raise
    except subprocess.CalledProcessError as e:
        error(f"Command failed: {' '.join(cmd)}")
        if e.stderr:
            stderr = e.stderr.strip()
            print(f"\n{stderr}", file=sys.stderr)

            # Provide helpful context for common errors
            if "No space left on device" in stderr:
                print("\nðŸ’¡ Tip: Free up disk space and try again", file=sys.stderr)
            elif "Could not find a version" in stderr or "No matching distribution" in stderr:
                print("\nðŸ’¡ Tip: Check package name spelling or try a different version", file=sys.stderr)
            elif "Connection" in stderr or "Network" in stderr or "timed out" in stderr:
                print("\nðŸ’¡ Tip: Check your internet connection and try again", file=sys.stderr)
            elif "Permission denied" in stderr:
                print("\nðŸ’¡ Tip: Check file permissions or run with appropriate access", file=sys.stderr)
        raise
    except FileNotFoundError:
        error(f"Command not found: {cmd[0]}")
        error("Make sure all required tools are installed")
        raise


def pip_freeze() -> str:
    """Get current pip freeze output"""
    pip_bin = VENV_PATH / "bin" / "pip"
    if not pip_bin.exists():
        return ""
    result = run_command([str(pip_bin), "freeze"])
    return result.stdout


def get_history_id() -> int:
    """Get next history entry ID with file locking to prevent race conditions"""
    ensure_dirs()

    # Use file locking to prevent concurrent access
    lock_file = LOCK_FILE
    lock_file.parent.mkdir(parents=True, exist_ok=True)

    with open(lock_file, 'w') as lock_fd:
        try:
            # Acquire exclusive lock (blocks if another process has it)
            fcntl.flock(lock_fd.fileno(), fcntl.LOCK_EX)

            if not HISTORY_PATH.exists():
                return 1

            max_id = 0
            for file in HISTORY_PATH.glob("*_before.json"):
                try:
                    id_str = file.stem.split("_")[0]
                    max_id = max(max_id, int(id_str))
                except (ValueError, IndexError):
                    continue

            return max_id + 1
        finally:
            # Release lock
            fcntl.flock(lock_fd.fileno(), fcntl.LOCK_UN)


def venv_exists() -> bool:
    """Check if user venv exists"""
    return VENV_PATH.exists() and (VENV_PATH / "bin" / "python3").exists()


def ensure_dirs():
    """Ensure all necessary directories exist"""
    SYSVENV_ROOT.mkdir(parents=True, exist_ok=True)
    HISTORY_PATH.mkdir(exist_ok=True)
    SNAPSHOTS_PATH.mkdir(exist_ok=True)


def parse_freeze_to_dict(freeze_output: str) -> Dict[str, str]:
    """Parse pip freeze output into {package: version} dict"""
    packages = {}
    for line in freeze_output.strip().split('\n'):
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        if '==' in line:
            pkg, ver = line.split('==', 1)
            packages[pkg.strip()] = ver.strip()
    return packages


def diff_packages(before: str, after: str) -> Tuple[List[str], List[str], List[str]]:
    """Calculate package diff (added, removed, modified)"""
    before_pkgs = parse_freeze_to_dict(before)
    after_pkgs = parse_freeze_to_dict(after)

    added = []
    removed = []
    modified = []

    for pkg, ver in after_pkgs.items():
        if pkg not in before_pkgs:
            added.append(f"{pkg}=={ver}")
        elif before_pkgs[pkg] != ver:
            modified.append(f"{pkg}: {before_pkgs[pkg]} â†’ {ver}")

    for pkg, ver in before_pkgs.items():
        if pkg not in after_pkgs:
            removed.append(f"{pkg}=={ver}")

    return added, removed, modified


def check_disk_space(path: Path, required_mb: int = 100) -> bool:
    """Check if there's enough disk space available"""
    try:
        stat = os.statvfs(path.parent if path.is_file() else path)
        # Available space in MB
        available_mb = (stat.f_bavail * stat.f_frsize) / (1024 * 1024)
        return available_mb >= required_mb
    except Exception:
        # If we can't check, assume it's okay
        return True


def validate_snapshot_name(name: str) -> bool:
    """Validate snapshot name (alphanumeric, dash, underscore only)"""
    import re

    # Check basic pattern
    if not re.match(r'^[a-zA-Z0-9_-]+$', name):
        return False

    # Check length
    if len(name) > MAX_SNAPSHOT_NAME_LENGTH:
        return False

    # Check for reserved names
    if name.lower() in RESERVED_SNAPSHOT_NAMES:
        return False

    # Reject names starting with dash or dot (shell safety)
    if name.startswith('-') or name.startswith('.'):
        return False

    return True


def confirm_action(message: str, default: bool = False) -> bool:
    """Ask user for confirmation"""
    if os.getenv("SYSVENV_YES"):
        return True

    prompt = f"{message} [y/N]: " if not default else f"{message} [Y/n]: "
    try:
        response = input(prompt).strip().lower()
        if not response:
            return default
        return response in ['y', 'yes']
    except (KeyboardInterrupt, EOFError):
        print()
        return False


def safe_read_json(file_path: Path) -> Optional[Dict]:
    """Safely read JSON file with error handling"""
    try:
        with open(file_path) as f:
            return json.load(f)
    except json.JSONDecodeError:
        warning(f"Corrupted JSON file: {file_path}")
        return None
    except FileNotFoundError:
        return None
    except Exception as e:
        warning(f"Error reading {file_path}: {e}")
        return None


def atomic_write_json(file_path: Path, data: Dict):
    """Atomically write JSON file to prevent corruption"""
    # Write to temporary file first
    tmp_path = file_path.parent / f".{file_path.name}.tmp"
    try:
        with open(tmp_path, 'w') as f:
            json.dump(data, f, indent=2)
        # Atomic replace (POSIX guarantees atomicity)
        os.replace(tmp_path, file_path)
    except Exception:
        # Clean up temp file on error
        if tmp_path.exists():
            tmp_path.unlink()
        raise


def atomic_write_text(file_path: Path, content: str):
    """Atomically write text file to prevent corruption"""
    tmp_path = file_path.parent / f".{file_path.name}.tmp"
    try:
        tmp_path.write_text(content)
        # Atomic replace
        os.replace(tmp_path, file_path)
    except Exception:
        if tmp_path.exists():
            tmp_path.unlink()
        raise


def safe_rmtree(path: Path, check_symlink: bool = True):
    """Safely remove directory tree with symlink protection"""
    if not path.exists():
        return

    # Check if it's a symlink
    if check_symlink and path.is_symlink():
        error(f"Refusing to remove symlink: {path}")
        error("This could be a security attack. Please remove manually.")
        raise ValueError(f"Path is a symlink: {path}")

    # Verify path is within expected boundaries
    try:
        real_path = path.resolve()
        expected_parent = SYSVENV_ROOT.resolve()

        if not str(real_path).startswith(str(expected_parent)):
            error(f"Path {path} resolves outside sysvenv directory")
            error(f"Real path: {real_path}")
            error(f"Expected under: {expected_parent}")
            raise ValueError("Path traversal detected")
    except Exception as e:
        error(f"Path validation failed: {e}")
        raise

    # Safe to remove
    shutil.rmtree(path)


def check_system_packages(package_names: List[str]) -> List[Tuple[str, str]]:
    """Check if packages are installed via system package manager

    Returns list of (package_name, system_package_name) tuples for conflicts
    """
    conflicts = []

    # Check for dpkg/apt (Debian/Ubuntu)
    if shutil.which('dpkg'):
        for pkg in package_names:
            # System packages are typically named python3-<package>
            system_pkg = f"python3-{pkg.lower()}"
            try:
                result = subprocess.run(
                    ['dpkg', '-l', system_pkg],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                # dpkg -l returns 0 if package is installed
                if result.returncode == 0 and 'ii' in result.stdout:
                    conflicts.append((pkg, system_pkg))
            except (subprocess.TimeoutExpired, FileNotFoundError):
                pass

    # Check for rpm (RHEL/Fedora/CentOS)
    elif shutil.which('rpm'):
        for pkg in package_names:
            system_pkg = f"python3-{pkg.lower()}"
            try:
                result = subprocess.run(
                    ['rpm', '-q', system_pkg],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    conflicts.append((pkg, system_pkg))
            except (subprocess.TimeoutExpired, FileNotFoundError):
                pass

    return conflicts


def extract_package_names(pip_args: List[str]) -> List[str]:
    """Extract package names from pip command arguments"""
    packages = []
    skip_next = False

    for arg in pip_args:
        if skip_next:
            skip_next = False
            continue

        # Skip flags
        if arg.startswith('-'):
            # Some flags take values
            if arg in ['-r', '--requirement', '-c', '--constraint', '-e', '--editable']:
                skip_next = True
            continue

        # Skip subcommands
        if arg in ['install', 'uninstall', 'upgrade']:
            continue

        # Extract package name (handle package==version, package>=version, etc.)
        pkg_name = arg.split('==')[0].split('>=')[0].split('<=')[0].split('!=')[0].split('~=')[0].split('[')[0]
        if pkg_name and not pkg_name.startswith('git+') and not pkg_name.startswith('http'):
            packages.append(pkg_name)

    return packages


def get_package_provenance(package_name: str) -> Optional[Dict]:
    """Get package installation source and metadata"""
    if not venv_exists():
        return None

    pip_bin = VENV_PATH / "bin" / "pip"
    try:
        result = run_command([str(pip_bin), "show", package_name], check=False)
        if result.returncode != 0:
            return None

        provenance = {
            "name": package_name,
            "source": "pypi",  # default assumption
            "metadata": {}
        }

        # Parse pip show output
        for line in result.stdout.split('\n'):
            if ':' in line:
                key, value = line.split(':', 1)
                key = key.strip()
                value = value.strip()

                if key == "Version":
                    provenance["metadata"]["version"] = value
                elif key == "Location":
                    location = value
                    provenance["metadata"]["location"] = location

                    # Detect source from location
                    if "site-packages" in location:
                        if ".egg-link" in location or "-e" in location:
                            provenance["source"] = "editable"
                        else:
                            provenance["source"] = "pypi"
                    elif "src" in location.lower():
                        provenance["source"] = "git"
                elif key == "Installer":
                    provenance["metadata"]["installer"] = value

        return provenance

    except Exception:
        return None


def track_installation_provenance(pip_args: List[str]) -> Dict[str, Dict]:
    """Track provenance for packages being installed"""
    provenance_map = {}

    # Detect installation source from command args
    for i, arg in enumerate(pip_args):
        if arg.startswith('git+'):
            # Git installation
            pkg_url = arg.split('git+')[1]
            pkg_name = pkg_url.split('/')[-1].split('.git')[0]
            provenance_map[pkg_name] = {
                "source": "git",
                "url": pkg_url,
                "command_arg": arg
            }
        elif arg.startswith('http://') or arg.startswith('https://'):
            # URL installation
            pkg_name = arg.split('/')[-1].split('-')[0]
            provenance_map[pkg_name] = {
                "source": "url",
                "url": arg
            }
        elif arg == '-e' and i + 1 < len(pip_args):
            # Editable install
            path = pip_args[i + 1]
            pkg_name = Path(path).name
            provenance_map[pkg_name] = {
                "source": "editable",
                "path": path
            }
        elif arg.startswith('-e'):
            # -e inline
            path = arg[2:]
            pkg_name = Path(path).name
            provenance_map[pkg_name] = {
                "source": "editable",
                "path": path
            }

    return provenance_map


def suggest_snapshot_if_stable(pkg_count: int, history_count: int, named_snapshot_count: int) -> bool:
    """Heuristic to suggest creating a snapshot

    Returns True if environment appears stable and worth snapshotting
    """
    # Don't suggest if already have named snapshots
    if named_snapshot_count > 0:
        return False

    # Don't suggest for minimal environments
    if pkg_count < 15:
        return False

    # Don't suggest too early (let user build up environment first)
    if history_count < 3:
        return False

    # Check if recent activity suggests stability
    # If we have 15+ packages and 3+ operations but no named snapshots,
    # suggest saving the work
    if pkg_count >= 15 and history_count >= 3:
        return True

    # For larger environments, always suggest if no named snapshots
    if pkg_count >= 30:
        return True

    return False


def build_dependency_graph() -> Tuple[Dict[str, Set[str]], Dict[str, Set[str]]]:
    """Build dependency graph for installed packages

    Returns:
        (requires_map, required_by_map)
        requires_map: {package: set(packages it depends on)}
        required_by_map: {package: set(packages that depend on it)}
    """
    if not venv_exists():
        return {}, {}

    pip_bin = VENV_PATH / "bin" / "pip"

    requires_map = {}
    required_by_map = {}

    # Get list of installed packages
    freeze = pip_freeze()
    packages = [line.split('==')[0] for line in freeze.split('\n') if line.strip() and '==' in line]

    for pkg in packages:
        try:
            result = run_command([str(pip_bin), "show", pkg], check=False)
            if result.returncode != 0:
                continue

            requires = set()
            for line in result.stdout.split('\n'):
                if line.startswith('Requires:'):
                    deps = line.split(':', 1)[1].strip()
                    if deps and deps != '':
                        requires = set(d.strip() for d in deps.split(','))
                    break

            requires_map[pkg] = requires

            # Build reverse map
            for dep in requires:
                if dep not in required_by_map:
                    required_by_map[dep] = set()
                required_by_map[dep].add(pkg)

        except Exception:
            continue

    return requires_map, required_by_map


def find_orphan_packages(removed_packages: List[str]) -> List[str]:
    """Find packages that are only required by removed packages

    Args:
        removed_packages: List of package names that were removed

    Returns:
        List of orphaned package names
    """
    requires_map, required_by_map = build_dependency_graph()

    removed_set = set(pkg.lower() for pkg in removed_packages)
    orphans = []

    # Get all installed packages
    freeze = pip_freeze()
    all_packages = {line.split('==')[0].lower() for line in freeze.split('\n') if line.strip() and '==' in line}

    # For each installed package
    for pkg in all_packages:
        if pkg in removed_set:
            continue  # Skip packages we're removing

        # Get what requires this package
        required_by = required_by_map.get(pkg, set())
        required_by_lower = {r.lower() for r in required_by}

        # If only required by removed packages (or nothing), it's an orphan
        if required_by_lower and required_by_lower.issubset(removed_set):
            orphans.append(pkg)

    return orphans


# ============================================================================
# Commands
# ============================================================================

def cmd_init(args):
    """Initialize user venv"""
    heading("Initializing user Python environment")

    if venv_exists():
        warning("User venv already exists")
        info(f"Location: {VENV_PATH}")
        if not confirm_action("Reinitialize (this will delete existing venv)?"):
            return 0
        info("Removing existing venv...")
        safe_rmtree(VENV_PATH)

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        error(f"Location: {SYSVENV_ROOT}")
        return 1

    try:
        ensure_dirs()

        # Create venv
        info("Creating virtual environment...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)
        success(f"Created venv at {VENV_PATH}")

        # Upgrade pip
        info("Upgrading pip...")
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip"], capture=False)

        # Create baseline snapshot
        baseline_file = SNAPSHOTS_PATH / "baseline.txt"
        freeze = pip_freeze()
        atomic_write_text(baseline_file, freeze)
        success("Created baseline snapshot")

        heading("Setup complete!")
        print("\nNext steps:")
        print(f"  1. Add to your shell config (~/.bashrc or ~/.zshrc):")
        cprint(f'     export PATH="{VENV_PATH}/bin:$PATH"', Colors.CYAN)
        print(f"  2. Reload shell: source ~/.bashrc")
        print(f"  3. Start installing: pip install <package>")

        return 0

    except Exception as e:
        error(f"Initialization failed: {e}")
        error("Rolling back...")
        if VENV_PATH.exists():
            safe_rmtree(VENV_PATH)
        return 1


def cmd_status(args):
    """Show current status"""
    heading("Python Environment Status")

    if not venv_exists():
        error("User venv not initialized")
        print(f"\nRun: sysvenv init")
        return 1

    success(f"Venv exists: {VENV_PATH}")

    # Python version
    python_bin = VENV_PATH / "bin" / "python3"
    result = run_command([str(python_bin), "--version"])
    print(f"Python: {result.stdout.strip()}")

    # Pip version
    pip_bin = VENV_PATH / "bin" / "pip"
    result = run_command([str(pip_bin), "--version"])
    print(f"Pip: {result.stdout.strip()}")

    # Package count
    freeze = pip_freeze()
    pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])
    print(f"Installed packages: {pkg_count}")

    # History count
    history_count = len(list(HISTORY_PATH.glob("*_after.json")))
    print(f"History entries: {history_count}")

    # Snapshots
    snapshots = list(SNAPSHOTS_PATH.glob("*.txt"))
    named_snapshots = [s for s in snapshots if s.stem != "baseline"]
    print(f"Snapshots: {len(snapshots)}")
    if snapshots:
        print(f"  Available: {', '.join(s.stem for s in sorted(snapshots))}")

    # PATH check
    print("\nPATH check:")
    user_path = os.getenv("PATH", "")
    venv_bin_str = str(VENV_PATH / "bin")
    if venv_bin_str in user_path:
        if user_path.startswith(venv_bin_str):
            success(f"  âœ“ User venv is first in PATH")
        else:
            warning(f"  âš  User venv is in PATH but not first")
    else:
        error(f"  âœ— User venv not in PATH")
        print(f"\n  Add to ~/.bashrc:")
        cprint(f'  export PATH="{VENV_PATH}/bin:$PATH"', Colors.CYAN)

    # Smart snapshot reminder
    should_suggest = suggest_snapshot_if_stable(pkg_count, history_count, len(named_snapshots))
    if should_suggest:
        print()
        info("ðŸ’¡ Snapshot Suggestion:")
        print("  Your environment looks stable and well-developed!")
        print(f"  Consider saving a snapshot for backup:")
        cprint(f"  â†’ sysvenv snapshot my-environment", Colors.CYAN)

    return 0


def cmd_doctor(args):
    """Health check and repair"""
    heading("Running health checks")

    issues = []

    # Check if venv exists
    if not venv_exists():
        issues.append("User venv does not exist")
    else:
        success("User venv exists")

    # Check directories
    for path, name in [(HISTORY_PATH, "History"), (SNAPSHOTS_PATH, "Snapshots")]:
        if not path.exists():
            issues.append(f"{name} directory missing")
        else:
            success(f"{name} directory exists")

    # Check Python binary
    python_bin = VENV_PATH / "bin" / "python3"
    if venv_exists() and python_bin.exists():
        success("Python binary exists")
    elif venv_exists():
        issues.append("Python binary missing from venv")

    # Check pip
    pip_bin = VENV_PATH / "bin" / "pip"
    if venv_exists() and pip_bin.exists():
        success("Pip exists")
    elif venv_exists():
        issues.append("Pip missing from venv")

    # Check PATH
    user_path = os.getenv("PATH", "")
    venv_bin_str = str(VENV_PATH / "bin")
    if venv_bin_str in user_path:
        success("Venv in PATH")
    else:
        warning("Venv not in PATH (add to shell config)")

    # Summary
    if issues:
        heading(f"\nFound {len(issues)} issue(s):")
        for issue in issues:
            error(f"  â€¢ {issue}")

        if args.fix:
            heading("\nAttempting repairs...")
            ensure_dirs()

            if not venv_exists():
                info("Creating venv...")
                return cmd_init(args)

            success("Repairs complete")
            return 0
        else:
            print("\nRun with --fix to attempt repairs")
            return 1
    else:
        success("\nâœ“ All checks passed!")
        return 0


def cmd_history(args):
    """Show operation history"""
    if not HISTORY_PATH.exists():
        warning("No history yet")
        return 0

    # Get all after.json files (completed operations)
    history_files = sorted(HISTORY_PATH.glob("*_after.json"))

    if not history_files:
        warning("No history yet")
        return 0

    # Apply limit
    limit = args.limit if args.limit else len(history_files)
    history_files = history_files[-limit:]

    heading(f"Operation History (last {len(history_files)})")

    corrupted_count = 0
    for file in reversed(history_files):
        entry = safe_read_json(file)
        if not entry:
            corrupted_count += 1
            continue

        entry_id = entry.get("id", "?")
        timestamp = entry.get("timestamp", "")
        # Parse timestamp and format nicely
        if timestamp:
            try:
                dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                timestamp = dt.strftime("%Y-%m-%d %H:%M:%S")
            except Exception:
                timestamp = "unknown"

        command = entry.get("command", "")

        # Show changes summary
        changes = entry.get("changes", {})
        added = len(changes.get("added", []))
        removed = len(changes.get("removed", []))
        modified = len(changes.get("modified", []))

        change_summary = []
        if added:
            change_summary.append(f"+{added}")
        if removed:
            change_summary.append(f"-{removed}")
        if modified:
            change_summary.append(f"~{modified}")

        summary = f" [{', '.join(change_summary)}]" if change_summary else ""

        # Show provenance info if detailed mode
        provenance_info = ""
        if args.detailed and entry.get("provenance"):
            prov = entry.get("provenance", {})
            sources = set(p.get("source", "pypi") for p in prov.values())
            if sources and sources != {"pypi"}:
                provenance_info = f" [{', '.join(sources)}]"

        print(f"#{entry_id:3d}  {timestamp}  {command}{summary}{provenance_info}")

    if corrupted_count > 0:
        warning(f"\n{corrupted_count} corrupted history entries skipped")

    return 0


def cmd_diff(args):
    """Show diff from an operation"""
    entry_id = args.entry_id

    if entry_id is None:
        # Show last operation
        history_files = sorted(HISTORY_PATH.glob("*_after.json"))
        if not history_files:
            warning("No history yet")
            return 0

        with open(history_files[-1]) as f:
            entry = json.load(f)
        entry_id = entry.get("id")

    # Load the after entry
    after_file = HISTORY_PATH / f"{entry_id:03d}_after.json"
    if not after_file.exists():
        error(f"Operation #{entry_id} not found")
        return 1

    with open(after_file) as f:
        entry = json.load(f)

    heading(f"Operation #{entry_id}: {entry.get('command', '')}")

    changes = entry.get("changes", {})
    added = changes.get("added", [])
    removed = changes.get("removed", [])
    modified = changes.get("modified", [])

    # Get provenance if available
    provenance = entry.get("provenance", {})

    if added:
        print("\nAdded:")
        for pkg in added:
            pkg_name = pkg.split('==')[0]
            source_info = ""
            if pkg_name in provenance:
                source = provenance[pkg_name].get("source", "pypi")
                if source != "pypi":
                    source_info = f" [{source}]"
            cprint(f"  + {pkg}{source_info}", Colors.GREEN)

    if removed:
        print("\nRemoved:")
        for pkg in removed:
            cprint(f"  - {pkg}", Colors.RED)

    if modified:
        print("\nModified:")
        for pkg in modified:
            cprint(f"  ~ {pkg}", Colors.YELLOW)

    if not added and not removed and not modified:
        info("No changes")

    return 0


def cmd_undo(args):
    """Undo last N operations"""
    n = args.count

    if n < 1:
        error("Count must be at least 1")
        return 1

    if not venv_exists():
        error("User venv not initialized")
        return 1

    # Find the operation to roll back to
    history_files = sorted(HISTORY_PATH.glob("*_after.json"))
    if not history_files:
        warning("No history to undo")
        return 0

    if n > len(history_files):
        error(f"Only {len(history_files)} operations in history")
        return 1

    # We want to undo the last n operations
    # So we restore to the state BEFORE operation (len - n + 1)
    target_op = len(history_files) - n + 1

    before_file = HISTORY_PATH / f"{target_op:03d}_before.json"
    if not before_file.exists():
        error(f"Cannot find state before operation #{target_op}")
        return 1

    entry = safe_read_json(before_file)
    if not entry:
        error("Corrupted history file")
        return 1

    freeze_to_restore = entry.get("freeze", "")

    heading(f"Rolling back {n} operation(s)")
    info(f"Restoring to state before operation #{target_op}")

    if args.dry_run:
        warning("DRY RUN - no changes will be made")
        print("\nWould restore packages:")
        for line in freeze_to_restore.split('\n'):
            if line.strip():
                print(f"  {line}")
        return 0

    # Confirm if undoing more than 1 operation
    if n > 1 and not confirm_action(f"Undo last {n} operations?"):
        info("Cancelled")
        return 0

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        return 1

    try:
        # Nuke and recreate venv
        info("Removing current venv...")
        safe_rmtree(VENV_PATH)

        info("Creating fresh venv...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)

        # Upgrade pip
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip", "-q"])

        # Restore packages
        if freeze_to_restore.strip():
            info("Restoring packages...")
            # Write freeze to temp file
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(freeze_to_restore)
                temp_file = f.name

            try:
                run_command([str(pip_bin), "install", "-r", temp_file, "-q"], capture=False)
            finally:
                os.unlink(temp_file)

        success(f"Rolled back {n} operation(s)")
        return 0

    except Exception as e:
        error(f"Undo failed: {e}")
        error("Your venv may be in an inconsistent state. Run 'sysvenv doctor --fix' to repair.")
        return 1


def cmd_clean(args):
    """Nuke and recreate venv"""
    if not venv_exists():
        warning("User venv doesn't exist, nothing to clean")
        return 0

    heading("Cleaning user venv")

    restore_baseline = args.keep_baseline

    if args.dry_run:
        warning("DRY RUN - no changes will be made")
        print("\nWould:")
        print("  1. Delete venv")
        print("  2. Create fresh venv")
        if restore_baseline:
            print("  3. Restore baseline snapshot")
        return 0

    # Confirm deletion
    if not confirm_action("This will delete all installed packages. Continue?"):
        info("Cancelled")
        return 0

    # Check if baseline exists
    baseline_file = SNAPSHOTS_PATH / "baseline.txt"
    if restore_baseline and not baseline_file.exists():
        error("Baseline snapshot not found")
        return 1

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        return 1

    try:
        # Nuke venv
        info("Removing venv...")
        safe_rmtree(VENV_PATH)

        # Recreate
        info("Creating fresh venv...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)

        # Upgrade pip
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip", "-q"])

        # Restore baseline if requested
        if restore_baseline:
            info("Restoring baseline snapshot...")
            freeze = baseline_file.read_text()
            if freeze.strip():
                import tempfile
                with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                    f.write(freeze)
                    temp_file = f.name

                try:
                    run_command([str(pip_bin), "install", "-r", temp_file, "-q"], capture=False)
                finally:
                    os.unlink(temp_file)

        success("Venv cleaned and recreated")
        return 0

    except Exception as e:
        error(f"Clean failed: {e}")
        error("Your venv may be in an inconsistent state. Run 'sysvenv doctor --fix' to repair.")
        return 1


def cmd_snapshot(args):
    """Save named snapshot"""
    name = args.name

    if not venv_exists():
        error("User venv not initialized")
        return 1

    # Validate snapshot name
    if not validate_snapshot_name(name):
        error(f"Invalid snapshot name: '{name}'")
        error("Requirements:")
        error(f"  â€¢ Alphanumeric, dashes, and underscores only")
        error(f"  â€¢ Maximum {MAX_SNAPSHOT_NAME_LENGTH} characters")
        error(f"  â€¢ Cannot use reserved names: {', '.join(RESERVED_SNAPSHOT_NAMES)}")
        error(f"  â€¢ Cannot start with '-' or '.'")
        return 1

    snapshot_file = SNAPSHOTS_PATH / f"{name}.txt"

    if snapshot_file.exists() and not args.force:
        error(f"Snapshot '{name}' already exists (use --force to overwrite)")
        info(f"Existing snapshots: sysvenv list-snapshots")
        return 1

    try:
        freeze = pip_freeze()
        atomic_write_text(snapshot_file, freeze)

        # Count packages
        pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])
        success(f"Saved snapshot '{name}' ({pkg_count} packages)")

        return 0

    except Exception as e:
        error(f"Failed to save snapshot: {e}")
        return 1


def cmd_restore(args):
    """Restore named snapshot"""
    name = args.name

    if not venv_exists():
        error("User venv not initialized")
        return 1

    snapshot_file = SNAPSHOTS_PATH / f"{name}.txt"

    if not snapshot_file.exists():
        error(f"Snapshot '{name}' not found")
        info("Available snapshots: sysvenv list-snapshots")
        return 1

    freeze = snapshot_file.read_text()
    pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])

    heading(f"Restoring snapshot '{name}' ({pkg_count} packages)")

    if args.dry_run:
        warning("DRY RUN - no changes will be made")
        print("\nWould restore packages:")
        for line in freeze.split('\n'):
            if line.strip():
                print(f"  {line}")
        return 0

    # Confirm restoration
    if not confirm_action(f"This will delete current venv and restore '{name}'. Continue?"):
        info("Cancelled")
        return 0

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        return 1

    try:
        # Nuke and recreate venv
        info("Removing current venv...")
        safe_rmtree(VENV_PATH)

        info("Creating fresh venv...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)

        # Upgrade pip
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip", "-q"])

        # Restore packages
        if freeze.strip():
            info("Restoring packages...")
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(freeze)
                temp_file = f.name

            try:
                run_command([str(pip_bin), "install", "-r", temp_file, "-q"], capture=False)
            finally:
                os.unlink(temp_file)

        success(f"Restored snapshot '{name}'")
        return 0

    except Exception as e:
        error(f"Restore failed: {e}")
        error("Your venv may be in an inconsistent state. Run 'sysvenv doctor --fix' to repair.")
        return 1


def cmd_list_snapshots(args):
    """List available snapshots"""
    snapshots = sorted(SNAPSHOTS_PATH.glob("*.txt"))

    if not snapshots:
        warning("No snapshots yet")
        return 0

    heading("Available Snapshots")

    for snap in snapshots:
        name = snap.stem
        size = snap.stat().st_size
        mtime = datetime.fromtimestamp(snap.stat().st_mtime)

        # Count packages
        freeze = snap.read_text()
        pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])

        print(f"  {name:20s}  {pkg_count:3d} packages  {mtime.strftime('%Y-%m-%d %H:%M')}")

    return 0


def cmd_share(args):
    """Export snapshot for sharing with teammates"""
    name = args.name if args.name else "shared-env"

    if not venv_exists():
        error("User venv not initialized")
        return 1

    # Validate snapshot name if provided
    if args.name and not validate_snapshot_name(name):
        error(f"Invalid snapshot name: '{name}'")
        return 1

    try:
        # Get current Python version
        python_bin = VENV_PATH / "bin" / "python3"
        result = run_command([str(python_bin), "--version"])
        python_version = result.stdout.strip()

        # Get pip freeze
        freeze = pip_freeze()
        pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])

        # Create metadata
        metadata = {
            "created_at": datetime.utcnow().isoformat() + "Z",
            "created_by": os.getenv("USER", "unknown"),
            "python_version": python_version,
            "package_count": pkg_count,
            "hostname": os.getenv("HOSTNAME", "unknown")
        }

        # Create shareable file
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        share_filename = f"{name}-{timestamp}.sysvenv"
        share_path = Path.cwd() / share_filename

        # Write metadata and packages
        with open(share_path, 'w') as f:
            f.write("# sysvenv shared environment\n")
            f.write(f"# Created: {metadata['created_at']}\n")
            f.write(f"# Python: {metadata['python_version']}\n")
            f.write(f"# Packages: {metadata['package_count']}\n")
            f.write(f"# By: {metadata['created_by']}@{metadata['hostname']}\n")
            f.write("#\n")
            f.write("# To import: sysvenv import " + share_filename + "\n")
            f.write("\n")
            f.write(freeze)

        success(f"Created shareable environment: {share_filename}")
        print(f"\nEnvironment details:")
        print(f"  Python: {python_version}")
        print(f"  Packages: {pkg_count}")
        print(f"\nShare this file with teammates:")
        cprint(f"  {share_path}", Colors.CYAN)
        print(f"\nThey can import it with:")
        cprint(f"  sysvenv import {share_filename}", Colors.CYAN)

        return 0

    except Exception as e:
        error(f"Failed to create shareable environment: {e}")
        return 1


def cmd_import(args):
    """Import a shared environment snapshot"""
    share_file = Path(args.file)

    if not share_file.exists():
        error(f"File not found: {share_file}")
        return 1

    if not venv_exists():
        error("User venv not initialized. Run: sysvenv init")
        return 1

    try:
        # Read the file
        content = share_file.read_text()

        # Extract metadata from comments
        metadata = {}
        freeze_lines = []
        for line in content.split('\n'):
            if line.startswith('# Python:'):
                metadata['python'] = line.split(':', 1)[1].strip()
            elif line.startswith('# Packages:'):
                metadata['packages'] = line.split(':', 1)[1].strip()
            elif line.startswith('# By:'):
                metadata['created_by'] = line.split(':', 1)[1].strip()
            elif not line.startswith('#'):
                freeze_lines.append(line)

        freeze = '\n'.join(freeze_lines).strip()
        pkg_count = len([l for l in freeze.split('\n') if l.strip()])

        heading("Importing shared environment")
        print(f"  From: {metadata.get('created_by', 'unknown')}")
        print(f"  Python: {metadata.get('python', 'unknown')}")
        print(f"  Packages: {pkg_count}")

        # Check Python version compatibility
        python_bin = VENV_PATH / "bin" / "python3"
        result = run_command([str(python_bin), "--version"])
        current_python = result.stdout.strip()

        if metadata.get('python') and metadata['python'] != current_python:
            warning(f"Python version mismatch!")
            print(f"  Shared environment: {metadata['python']}")
            print(f"  Your environment: {current_python}")
            if not confirm_action("Continue anyway?"):
                info("Cancelled")
                return 0

        if args.dry_run:
            warning("DRY RUN - no changes will be made")
            print("\nWould restore packages:")
            for line in freeze.split('\n')[:10]:
                if line.strip():
                    print(f"  {line}")
            if pkg_count > 10:
                print(f"  ... and {pkg_count - 10} more")
            return 0

        # Confirm restoration
        if not confirm_action(f"This will replace your current venv with {pkg_count} packages. Continue?"):
            info("Cancelled")
            return 0

        # Check disk space
        if not check_disk_space(SYSVENV_ROOT, 500):
            error("Low disk space (need at least 500MB)")
            return 1

        # Nuke and recreate venv
        info("Removing current venv...")
        safe_rmtree(VENV_PATH)

        info("Creating fresh venv...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)

        # Upgrade pip
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip", "-q"])

        # Restore packages
        if freeze:
            info(f"Installing {pkg_count} packages...")
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(freeze)
                temp_file = f.name

            try:
                run_command([str(pip_bin), "install", "-r", temp_file], capture=False)
            finally:
                os.unlink(temp_file)

        success("Imported shared environment successfully")

        return 0

    except Exception as e:
        error(f"Import failed: {e}")
        error("Your venv may be in an inconsistent state. Run 'sysvenv doctor --fix' to repair.")
        return 1


# ============================================================================
# Internal commands (used by pip wrapper)
# ============================================================================

def cmd_snapshot_before(args):
    """Internal: Take before snapshot"""
    ensure_dirs()

    entry_id = get_history_id()
    freeze = pip_freeze()

    # Track provenance for packages being installed
    provenance = {}
    if args.command and args.command[0] == 'install':
        provenance = track_installation_provenance(args.command)

    entry = {
        "id": entry_id,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "user": os.getenv("USER", "unknown"),
        "command": " ".join(args.command),
        "pip_args": args.command,
        "freeze": freeze,
        "provenance": provenance
    }

    before_file = HISTORY_PATH / f"{entry_id:03d}_before.json"
    atomic_write_json(before_file, entry)

    return 0


def cmd_snapshot_after(args):
    """Internal: Take after snapshot"""
    # Find the most recent before snapshot
    before_files = sorted(HISTORY_PATH.glob("*_before.json"))
    if not before_files:
        return 0

    before_file = before_files[-1]
    with open(before_file) as f:
        before_entry = json.load(f)

    entry_id = before_entry["id"]
    before_freeze = before_entry["freeze"]
    after_freeze = pip_freeze()

    # Calculate diff
    added, removed, modified = diff_packages(before_freeze, after_freeze)

    after_entry = before_entry.copy()
    after_entry["freeze"] = after_freeze
    after_entry["changes"] = {
        "added": added,
        "removed": removed,
        "modified": modified
    }
    after_entry["exit_code"] = 0

    after_file = HISTORY_PATH / f"{entry_id:03d}_after.json"
    atomic_write_json(after_file, after_entry)

    # Show diff
    if added or removed or modified:
        heading("Changes:")
        if added:
            for pkg in added:
                cprint(f"  + {pkg}", Colors.GREEN)
        if removed:
            for pkg in removed:
                cprint(f"  - {pkg}", Colors.RED)
        if modified:
            for pkg in modified:
                cprint(f"  ~ {pkg}", Colors.YELLOW)

        info(f"Saved as operation #{entry_id}")

    return 0


def cmd_check_conflicts(args):
    """Internal: Check for system package conflicts before pip install"""
    # Extract package names from pip command
    packages = extract_package_names(args.command)

    if not packages:
        return 0

    # Check for system package conflicts
    conflicts = check_system_packages(packages)

    if conflicts:
        warning("System package conflicts detected:")
        for pkg, sys_pkg in conflicts:
            print(f"  â€¢ {pkg}: system has {sys_pkg} installed")

        print("\nðŸ’¡ Recommendations:")
        print("  1. Use system package manager (apt/yum) for system-wide installs")
        print("  2. Continue with pip (may cause conflicts)")
        print("  3. Create isolated project venv (recommended for projects)")
        print()

    return 0


def cmd_check_orphans(args):
    """Internal: Check for orphaned packages after uninstall"""
    # Get removed packages from the most recent operation
    history_files = sorted(HISTORY_PATH.glob("*_after.json"))
    if not history_files:
        return 0

    # Load the most recent operation
    with open(history_files[-1]) as f:
        entry = json.load(f)

    changes = entry.get("changes", {})
    removed = changes.get("removed", [])

    if not removed:
        return 0

    # Extract package names (remove version info)
    removed_names = [pkg.split('==')[0] for pkg in removed]

    # Find orphans
    orphans = find_orphan_packages(removed_names)

    if orphans:
        print()
        warning("Orphaned packages detected:")
        print("  These packages were only required by what you removed:")
        for pkg in orphans:
            print(f"    â€¢ {pkg}")

        print("\nðŸ’¡ You can remove them with:")
        cprint(f"  pip uninstall {' '.join(orphans)}", Colors.CYAN)
        print()

    return 0


def detect_version_downgrades(pip_args: List[str]) -> List[Tuple[str, str, str]]:
    """Detect if pip install would downgrade packages

    Returns list of (package, current_version, new_version) tuples for downgrades
    """
    if not venv_exists():
        return []

    pip_bin = VENV_PATH / "bin" / "pip"

    # Get current package versions
    current_packages = parse_freeze_to_dict(pip_freeze())

    downgrades = []

    try:
        # Run pip install with --dry-run to see what would happen
        cmd = [str(pip_bin), "install", "--dry-run"] + pip_args[1:]  # Skip 'install' in args
        result = run_command(cmd, check=False, capture=True)

        if result.returncode != 0:
            return []  # Can't determine, let pip handle it

        # Parse output for version changes
        # Look for patterns like "Would install package-1.0.0" when package-2.0.0 is installed
        output = result.stdout + result.stderr

        for line in output.split('\n'):
            # pip shows "Would install: package==1.0.0"
            if 'Would install' in line or 'would be installed' in line.lower():
                # Extract packages from line
                # Format varies, but typically: "package==version"
                parts = line.split()
                for part in parts:
                    if '==' in part:
                        pkg_name, new_version = part.strip(',').split('==', 1)
                        pkg_name_lower = pkg_name.lower()

                        # Check if this is a downgrade
                        if pkg_name_lower in current_packages:
                            current_version = current_packages[pkg_name_lower]
                            # Simple version comparison (not perfect but MVP)
                            if is_version_downgrade(current_version, new_version):
                                downgrades.append((pkg_name, current_version, new_version))

    except Exception:
        # If we can't detect, don't block the install
        return []

    return downgrades


def is_version_downgrade(current: str, new: str) -> bool:
    """Simple version comparison to detect downgrades

    MVP: Uses string comparison for major version numbers
    """
    try:
        # Parse versions (handle X.Y.Z format)
        current_parts = [int(x) for x in current.split('.')[:3]]
        new_parts = [int(x) for x in new.split('.')[:3]]

        # Pad to same length
        while len(current_parts) < 3:
            current_parts.append(0)
        while len(new_parts) < 3:
            new_parts.append(0)

        # Compare
        return new_parts < current_parts

    except (ValueError, AttributeError):
        # Can't parse, assume not a downgrade
        return False


def cmd_check_downgrades(args):
    """Internal: Check for potential downgrades before install"""
    if not args.command or args.command[0] != 'install':
        return 0

    downgrades = detect_version_downgrades(args.command)

    if downgrades:
        print()
        warning("Potential version downgrades detected:")
        for pkg, current, new in downgrades:
            print(f"  â€¢ {pkg}: {current} â†’ {new}")

        print("\nðŸ’¡ This may break dependencies. Consider:")
        print("  1. Check why downgrade is happening")
        print("  2. Use specific versions: pip install package==version")
        print("  3. Create a test venv first")
        print()

    return 0


# ============================================================================
# CLI Setup
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Two-Tier Python Package System Manager",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    # Global options
    parser.add_argument('-y', '--yes', action='store_true',
                        help='Skip confirmation prompts')

    subparsers = parser.add_subparsers(dest='command', help='Command to run')

    # init
    parser_init = subparsers.add_parser('init', help='Initialize user venv')
    parser_init.set_defaults(func=cmd_init)

    # status
    parser_status = subparsers.add_parser('status', help='Show current status')
    parser_status.set_defaults(func=cmd_status)

    # doctor
    parser_doctor = subparsers.add_parser('doctor', help='Health check and repair')
    parser_doctor.add_argument('--fix', action='store_true', help='Attempt to fix issues')
    parser_doctor.set_defaults(func=cmd_doctor)

    # history
    parser_history = subparsers.add_parser('history', help='Show operation history')
    parser_history.add_argument('--limit', type=int, help='Limit number of entries')
    parser_history.add_argument('--detailed', action='store_true', help='Show provenance information')
    parser_history.set_defaults(func=cmd_history)

    # diff
    parser_diff = subparsers.add_parser('diff', help='Show changes from operation')
    parser_diff.add_argument('entry_id', type=int, nargs='?', help='Operation ID (default: last)')
    parser_diff.set_defaults(func=cmd_diff)

    # undo
    parser_undo = subparsers.add_parser('undo', help='Undo last N operations')
    parser_undo.add_argument('count', type=int, nargs='?', default=1, help='Number of operations to undo')
    parser_undo.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser_undo.set_defaults(func=cmd_undo)

    # clean
    parser_clean = subparsers.add_parser('clean', help='Nuke and recreate venv')
    parser_clean.add_argument('--keep-baseline', action='store_true', help='Restore baseline after clean')
    parser_clean.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser_clean.set_defaults(func=cmd_clean)

    # snapshot
    parser_snapshot = subparsers.add_parser('snapshot', help='Save named snapshot')
    parser_snapshot.add_argument('name', help='Snapshot name')
    parser_snapshot.add_argument('--force', action='store_true', help='Overwrite existing snapshot')
    parser_snapshot.set_defaults(func=cmd_snapshot)

    # restore
    parser_restore = subparsers.add_parser('restore', help='Restore named snapshot')
    parser_restore.add_argument('name', help='Snapshot name')
    parser_restore.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser_restore.set_defaults(func=cmd_restore)

    # list-snapshots
    parser_list = subparsers.add_parser('list-snapshots', help='List available snapshots')
    parser_list.set_defaults(func=cmd_list_snapshots)

    # share
    parser_share = subparsers.add_parser('share', help='Export environment for sharing')
    parser_share.add_argument('name', nargs='?', help='Name for shared environment (optional)')
    parser_share.set_defaults(func=cmd_share)

    # import
    parser_import = subparsers.add_parser('import', help='Import shared environment')
    parser_import.add_argument('file', help='Path to .sysvenv file')
    parser_import.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser_import.set_defaults(func=cmd_import)

    # Internal commands (used by pip wrapper)
    parser_sb = subparsers.add_parser('_snapshot-before', help=argparse.SUPPRESS)
    parser_sb.add_argument('command', nargs='+')
    parser_sb.set_defaults(func=cmd_snapshot_before)

    parser_sa = subparsers.add_parser('_snapshot-after', help=argparse.SUPPRESS)
    parser_sa.add_argument('command', nargs='+')
    parser_sa.set_defaults(func=cmd_snapshot_after)

    parser_cc = subparsers.add_parser('_check-conflicts', help=argparse.SUPPRESS)
    parser_cc.add_argument('command', nargs='+')
    parser_cc.set_defaults(func=cmd_check_conflicts)

    parser_co = subparsers.add_parser('_check-orphans', help=argparse.SUPPRESS)
    parser_co.add_argument('command', nargs='+')
    parser_co.set_defaults(func=cmd_check_orphans)

    parser_cd = subparsers.add_parser('_check-downgrades', help=argparse.SUPPRESS)
    parser_cd.add_argument('command', nargs='+')
    parser_cd.set_defaults(func=cmd_check_downgrades)

    # Parse and run
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # Set SYSVENV_YES if --yes flag provided
    if getattr(args, 'yes', False):
        os.environ["SYSVENV_YES"] = "1"

    try:
        return args.func(args)
    except KeyboardInterrupt:
        print("\n\nInterrupted")
        return 130
    except Exception as e:
        error(f"Unexpected error: {e}")
        if os.getenv("DEBUG"):
            raise
        return 1


if __name__ == "__main__":
    sys.exit(main())
