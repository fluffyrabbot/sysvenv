#!/usr/bin/env python3
"""
sysvenv - Two-Tier Python Package System Manager

Manages user-level Python virtual environment with automatic snapshots,
history tracking, and easy undo/rollback capabilities.
"""

import argparse
import json
import os
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import venv


# ============================================================================
# Constants & Paths
# ============================================================================

HOME = Path.home()
SYSVENV_ROOT = HOME / ".local" / "python-packages"
VENV_PATH = SYSVENV_ROOT / "venv"
HISTORY_PATH = SYSVENV_ROOT / "history"
SNAPSHOTS_PATH = SYSVENV_ROOT / "snapshots"
CONFIG_PATH = SYSVENV_ROOT / "config.toml"

DEFAULT_CONFIG = """[history]
max_entries = 100
auto_snapshot = true
show_diff_after_install = true

[snapshots]
auto_baseline = true

[ui]
color = true
verbose = false
"""


# ============================================================================
# Colors & Output
# ============================================================================

class Colors:
    """ANSI color codes for terminal output"""
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    GRAY = "\033[90m"


def color_enabled() -> bool:
    """Check if color output should be enabled"""
    return sys.stdout.isatty() and os.getenv("NO_COLOR") is None


def cprint(text: str, color: str = "", bold: bool = False):
    """Print colored text if color is enabled"""
    if color_enabled():
        style = Colors.BOLD if bold else ""
        print(f"{style}{color}{text}{Colors.RESET}")
    else:
        print(text)


def success(text: str):
    cprint(f"âœ“ {text}", Colors.GREEN)


def error(text: str):
    cprint(f"âœ— {text}", Colors.RED, bold=True)


def warning(text: str):
    cprint(f"âš  {text}", Colors.YELLOW)


def info(text: str):
    cprint(f"â„¹ {text}", Colors.BLUE)


def heading(text: str):
    cprint(f"\n{text}", Colors.CYAN, bold=True)


# ============================================================================
# Helpers
# ============================================================================

def run_command(cmd: List[str], capture: bool = True, check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command with better error handling"""
    try:
        if capture:
            return subprocess.run(cmd, capture_output=True, text=True, check=check, timeout=300)
        else:
            return subprocess.run(cmd, check=check, timeout=300)
    except subprocess.TimeoutExpired:
        error(f"Command timed out after 5 minutes: {' '.join(cmd)}")
        error("This might indicate network issues or a very large package")
        raise
    except subprocess.CalledProcessError as e:
        error(f"Command failed: {' '.join(cmd)}")
        if e.stderr:
            stderr = e.stderr.strip()
            print(f"\n{stderr}", file=sys.stderr)

            # Provide helpful context for common errors
            if "No space left on device" in stderr:
                print("\nðŸ’¡ Tip: Free up disk space and try again", file=sys.stderr)
            elif "Could not find a version" in stderr or "No matching distribution" in stderr:
                print("\nðŸ’¡ Tip: Check package name spelling or try a different version", file=sys.stderr)
            elif "Connection" in stderr or "Network" in stderr or "timed out" in stderr:
                print("\nðŸ’¡ Tip: Check your internet connection and try again", file=sys.stderr)
            elif "Permission denied" in stderr:
                print("\nðŸ’¡ Tip: Check file permissions or run with appropriate access", file=sys.stderr)
        raise
    except FileNotFoundError:
        error(f"Command not found: {cmd[0]}")
        error("Make sure all required tools are installed")
        raise


def pip_freeze() -> str:
    """Get current pip freeze output"""
    pip_bin = VENV_PATH / "bin" / "pip"
    if not pip_bin.exists():
        return ""
    result = run_command([str(pip_bin), "freeze"])
    return result.stdout


def get_history_id() -> int:
    """Get next history entry ID"""
    if not HISTORY_PATH.exists():
        return 1

    max_id = 0
    for file in HISTORY_PATH.glob("*_before.json"):
        try:
            id_str = file.stem.split("_")[0]
            max_id = max(max_id, int(id_str))
        except (ValueError, IndexError):
            continue

    return max_id + 1


def venv_exists() -> bool:
    """Check if user venv exists"""
    return VENV_PATH.exists() and (VENV_PATH / "bin" / "python3").exists()


def ensure_dirs():
    """Ensure all necessary directories exist"""
    SYSVENV_ROOT.mkdir(parents=True, exist_ok=True)
    HISTORY_PATH.mkdir(exist_ok=True)
    SNAPSHOTS_PATH.mkdir(exist_ok=True)


def parse_freeze_to_dict(freeze_output: str) -> Dict[str, str]:
    """Parse pip freeze output into {package: version} dict"""
    packages = {}
    for line in freeze_output.strip().split('\n'):
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        if '==' in line:
            pkg, ver = line.split('==', 1)
            packages[pkg.strip()] = ver.strip()
    return packages


def diff_packages(before: str, after: str) -> Tuple[List[str], List[str], List[str]]:
    """Calculate package diff (added, removed, modified)"""
    before_pkgs = parse_freeze_to_dict(before)
    after_pkgs = parse_freeze_to_dict(after)

    added = []
    removed = []
    modified = []

    for pkg, ver in after_pkgs.items():
        if pkg not in before_pkgs:
            added.append(f"{pkg}=={ver}")
        elif before_pkgs[pkg] != ver:
            modified.append(f"{pkg}: {before_pkgs[pkg]} â†’ {ver}")

    for pkg, ver in before_pkgs.items():
        if pkg not in after_pkgs:
            removed.append(f"{pkg}=={ver}")

    return added, removed, modified


def check_disk_space(path: Path, required_mb: int = 100) -> bool:
    """Check if there's enough disk space available"""
    try:
        stat = os.statvfs(path.parent if path.is_file() else path)
        # Available space in MB
        available_mb = (stat.f_bavail * stat.f_frsize) / (1024 * 1024)
        return available_mb >= required_mb
    except Exception:
        # If we can't check, assume it's okay
        return True


def validate_snapshot_name(name: str) -> bool:
    """Validate snapshot name (alphanumeric, dash, underscore only)"""
    import re
    return bool(re.match(r'^[a-zA-Z0-9_-]+$', name))


def confirm_action(message: str, default: bool = False) -> bool:
    """Ask user for confirmation"""
    if os.getenv("SYSVENV_YES"):
        return True

    prompt = f"{message} [y/N]: " if not default else f"{message} [Y/n]: "
    try:
        response = input(prompt).strip().lower()
        if not response:
            return default
        return response in ['y', 'yes']
    except (KeyboardInterrupt, EOFError):
        print()
        return False


def safe_read_json(file_path: Path) -> Optional[Dict]:
    """Safely read JSON file with error handling"""
    try:
        with open(file_path) as f:
            return json.load(f)
    except json.JSONDecodeError:
        warning(f"Corrupted JSON file: {file_path}")
        return None
    except FileNotFoundError:
        return None
    except Exception as e:
        warning(f"Error reading {file_path}: {e}")
        return None


# ============================================================================
# Commands
# ============================================================================

def cmd_init(args):
    """Initialize user venv"""
    heading("Initializing user Python environment")

    if venv_exists():
        warning("User venv already exists")
        info(f"Location: {VENV_PATH}")
        if not confirm_action("Reinitialize (this will delete existing venv)?"):
            return 0
        info("Removing existing venv...")
        shutil.rmtree(VENV_PATH)

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        error(f"Location: {SYSVENV_ROOT}")
        return 1

    try:
        ensure_dirs()

        # Create venv
        info("Creating virtual environment...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)
        success(f"Created venv at {VENV_PATH}")

        # Upgrade pip
        info("Upgrading pip...")
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip"], capture=False)

        # Create baseline snapshot
        baseline_file = SNAPSHOTS_PATH / "baseline.txt"
        freeze = pip_freeze()
        baseline_file.write_text(freeze)
        success("Created baseline snapshot")

        # Create default config if it doesn't exist
        if not CONFIG_PATH.exists():
            CONFIG_PATH.write_text(DEFAULT_CONFIG)
            success("Created default config")

        heading("Setup complete!")
        print("\nNext steps:")
        print(f"  1. Add to your shell config (~/.bashrc or ~/.zshrc):")
        cprint(f'     export PATH="{VENV_PATH}/bin:$PATH"', Colors.CYAN)
        print(f"  2. Reload shell: source ~/.bashrc")
        print(f"  3. Start installing: pip install <package>")

        return 0

    except Exception as e:
        error(f"Initialization failed: {e}")
        error("Rolling back...")
        if VENV_PATH.exists():
            shutil.rmtree(VENV_PATH)
        return 1


def cmd_status(args):
    """Show current status"""
    heading("Python Environment Status")

    if not venv_exists():
        error("User venv not initialized")
        print(f"\nRun: sysvenv init")
        return 1

    success(f"Venv exists: {VENV_PATH}")

    # Python version
    python_bin = VENV_PATH / "bin" / "python3"
    result = run_command([str(python_bin), "--version"])
    print(f"Python: {result.stdout.strip()}")

    # Pip version
    pip_bin = VENV_PATH / "bin" / "pip"
    result = run_command([str(pip_bin), "--version"])
    print(f"Pip: {result.stdout.strip()}")

    # Package count
    freeze = pip_freeze()
    pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])
    print(f"Installed packages: {pkg_count}")

    # History count
    history_count = len(list(HISTORY_PATH.glob("*_after.json")))
    print(f"History entries: {history_count}")

    # Snapshots
    snapshots = list(SNAPSHOTS_PATH.glob("*.txt"))
    print(f"Snapshots: {len(snapshots)}")
    if snapshots:
        print(f"  Available: {', '.join(s.stem for s in sorted(snapshots))}")

    # PATH check
    print("\nPATH check:")
    user_path = os.getenv("PATH", "")
    venv_bin_str = str(VENV_PATH / "bin")
    if venv_bin_str in user_path:
        if user_path.startswith(venv_bin_str):
            success(f"  âœ“ User venv is first in PATH")
        else:
            warning(f"  âš  User venv is in PATH but not first")
    else:
        error(f"  âœ— User venv not in PATH")
        print(f"\n  Add to ~/.bashrc:")
        cprint(f'  export PATH="{VENV_PATH}/bin:$PATH"', Colors.CYAN)

    return 0


def cmd_doctor(args):
    """Health check and repair"""
    heading("Running health checks")

    issues = []

    # Check if venv exists
    if not venv_exists():
        issues.append("User venv does not exist")
    else:
        success("User venv exists")

    # Check directories
    for path, name in [(HISTORY_PATH, "History"), (SNAPSHOTS_PATH, "Snapshots")]:
        if not path.exists():
            issues.append(f"{name} directory missing")
        else:
            success(f"{name} directory exists")

    # Check Python binary
    python_bin = VENV_PATH / "bin" / "python3"
    if venv_exists() and python_bin.exists():
        success("Python binary exists")
    elif venv_exists():
        issues.append("Python binary missing from venv")

    # Check pip
    pip_bin = VENV_PATH / "bin" / "pip"
    if venv_exists() and pip_bin.exists():
        success("Pip exists")
    elif venv_exists():
        issues.append("Pip missing from venv")

    # Check PATH
    user_path = os.getenv("PATH", "")
    venv_bin_str = str(VENV_PATH / "bin")
    if venv_bin_str in user_path:
        success("Venv in PATH")
    else:
        warning("Venv not in PATH (add to shell config)")

    # Check config
    if CONFIG_PATH.exists():
        success("Config file exists")
    else:
        issues.append("Config file missing")

    # Summary
    if issues:
        heading(f"\nFound {len(issues)} issue(s):")
        for issue in issues:
            error(f"  â€¢ {issue}")

        if args.fix:
            heading("\nAttempting repairs...")
            ensure_dirs()

            if not venv_exists():
                info("Creating venv...")
                return cmd_init(args)

            if not CONFIG_PATH.exists():
                CONFIG_PATH.write_text(DEFAULT_CONFIG)
                success("Created config file")

            success("Repairs complete")
            return 0
        else:
            print("\nRun with --fix to attempt repairs")
            return 1
    else:
        success("\nâœ“ All checks passed!")
        return 0


def cmd_history(args):
    """Show operation history"""
    if not HISTORY_PATH.exists():
        warning("No history yet")
        return 0

    # Get all after.json files (completed operations)
    history_files = sorted(HISTORY_PATH.glob("*_after.json"))

    if not history_files:
        warning("No history yet")
        return 0

    # Apply limit
    limit = args.limit if args.limit else len(history_files)
    history_files = history_files[-limit:]

    heading(f"Operation History (last {len(history_files)})")

    corrupted_count = 0
    for file in reversed(history_files):
        entry = safe_read_json(file)
        if not entry:
            corrupted_count += 1
            continue

        entry_id = entry.get("id", "?")
        timestamp = entry.get("timestamp", "")
        # Parse timestamp and format nicely
        if timestamp:
            try:
                dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                timestamp = dt.strftime("%Y-%m-%d %H:%M:%S")
            except Exception:
                timestamp = "unknown"

        command = entry.get("command", "")

        # Show changes summary
        changes = entry.get("changes", {})
        added = len(changes.get("added", []))
        removed = len(changes.get("removed", []))
        modified = len(changes.get("modified", []))

        change_summary = []
        if added:
            change_summary.append(f"+{added}")
        if removed:
            change_summary.append(f"-{removed}")
        if modified:
            change_summary.append(f"~{modified}")

        summary = f" [{', '.join(change_summary)}]" if change_summary else ""

        print(f"#{entry_id:3d}  {timestamp}  {command}{summary}")

    if corrupted_count > 0:
        warning(f"\n{corrupted_count} corrupted history entries skipped")

    return 0


def cmd_diff(args):
    """Show diff from an operation"""
    entry_id = args.entry_id

    if entry_id is None:
        # Show last operation
        history_files = sorted(HISTORY_PATH.glob("*_after.json"))
        if not history_files:
            warning("No history yet")
            return 0

        with open(history_files[-1]) as f:
            entry = json.load(f)
        entry_id = entry.get("id")

    # Load the after entry
    after_file = HISTORY_PATH / f"{entry_id:03d}_after.json"
    if not after_file.exists():
        error(f"Operation #{entry_id} not found")
        return 1

    with open(after_file) as f:
        entry = json.load(f)

    heading(f"Operation #{entry_id}: {entry.get('command', '')}")

    changes = entry.get("changes", {})
    added = changes.get("added", [])
    removed = changes.get("removed", [])
    modified = changes.get("modified", [])

    if added:
        print("\nAdded:")
        for pkg in added:
            cprint(f"  + {pkg}", Colors.GREEN)

    if removed:
        print("\nRemoved:")
        for pkg in removed:
            cprint(f"  - {pkg}", Colors.RED)

    if modified:
        print("\nModified:")
        for pkg in modified:
            cprint(f"  ~ {pkg}", Colors.YELLOW)

    if not added and not removed and not modified:
        info("No changes")

    return 0


def cmd_undo(args):
    """Undo last N operations"""
    n = args.count

    if n < 1:
        error("Count must be at least 1")
        return 1

    if not venv_exists():
        error("User venv not initialized")
        return 1

    # Find the operation to roll back to
    history_files = sorted(HISTORY_PATH.glob("*_after.json"))
    if not history_files:
        warning("No history to undo")
        return 0

    if n > len(history_files):
        error(f"Only {len(history_files)} operations in history")
        return 1

    # We want to undo the last n operations
    # So we restore to the state BEFORE operation (len - n + 1)
    target_op = len(history_files) - n + 1

    before_file = HISTORY_PATH / f"{target_op:03d}_before.json"
    if not before_file.exists():
        error(f"Cannot find state before operation #{target_op}")
        return 1

    entry = safe_read_json(before_file)
    if not entry:
        error("Corrupted history file")
        return 1

    freeze_to_restore = entry.get("freeze", "")

    heading(f"Rolling back {n} operation(s)")
    info(f"Restoring to state before operation #{target_op}")

    if args.dry_run:
        warning("DRY RUN - no changes will be made")
        print("\nWould restore packages:")
        for line in freeze_to_restore.split('\n'):
            if line.strip():
                print(f"  {line}")
        return 0

    # Confirm if undoing more than 1 operation
    if n > 1 and not confirm_action(f"Undo last {n} operations?"):
        info("Cancelled")
        return 0

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        return 1

    try:
        # Nuke and recreate venv
        info("Removing current venv...")
        shutil.rmtree(VENV_PATH)

        info("Creating fresh venv...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)

        # Upgrade pip
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip", "-q"])

        # Restore packages
        if freeze_to_restore.strip():
            info("Restoring packages...")
            # Write freeze to temp file
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(freeze_to_restore)
                temp_file = f.name

            try:
                run_command([str(pip_bin), "install", "-r", temp_file, "-q"], capture=False)
            finally:
                os.unlink(temp_file)

        success(f"Rolled back {n} operation(s)")
        return 0

    except Exception as e:
        error(f"Undo failed: {e}")
        error("Your venv may be in an inconsistent state. Run 'sysvenv doctor --fix' to repair.")
        return 1


def cmd_clean(args):
    """Nuke and recreate venv"""
    if not venv_exists():
        warning("User venv doesn't exist, nothing to clean")
        return 0

    heading("Cleaning user venv")

    restore_baseline = args.keep_baseline

    if args.dry_run:
        warning("DRY RUN - no changes will be made")
        print("\nWould:")
        print("  1. Delete venv")
        print("  2. Create fresh venv")
        if restore_baseline:
            print("  3. Restore baseline snapshot")
        return 0

    # Confirm deletion
    if not confirm_action("This will delete all installed packages. Continue?"):
        info("Cancelled")
        return 0

    # Check if baseline exists
    baseline_file = SNAPSHOTS_PATH / "baseline.txt"
    if restore_baseline and not baseline_file.exists():
        error("Baseline snapshot not found")
        return 1

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        return 1

    try:
        # Nuke venv
        info("Removing venv...")
        shutil.rmtree(VENV_PATH)

        # Recreate
        info("Creating fresh venv...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)

        # Upgrade pip
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip", "-q"])

        # Restore baseline if requested
        if restore_baseline:
            info("Restoring baseline snapshot...")
            freeze = baseline_file.read_text()
            if freeze.strip():
                import tempfile
                with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                    f.write(freeze)
                    temp_file = f.name

                try:
                    run_command([str(pip_bin), "install", "-r", temp_file, "-q"], capture=False)
                finally:
                    os.unlink(temp_file)

        success("Venv cleaned and recreated")
        return 0

    except Exception as e:
        error(f"Clean failed: {e}")
        error("Your venv may be in an inconsistent state. Run 'sysvenv doctor --fix' to repair.")
        return 1


def cmd_snapshot(args):
    """Save named snapshot"""
    name = args.name

    if not venv_exists():
        error("User venv not initialized")
        return 1

    # Validate snapshot name
    if not validate_snapshot_name(name):
        error(f"Invalid snapshot name: '{name}'")
        error("Use only alphanumeric characters, dashes, and underscores")
        return 1

    snapshot_file = SNAPSHOTS_PATH / f"{name}.txt"

    if snapshot_file.exists() and not args.force:
        error(f"Snapshot '{name}' already exists (use --force to overwrite)")
        info(f"Existing snapshots: sysvenv list-snapshots")
        return 1

    try:
        freeze = pip_freeze()
        snapshot_file.write_text(freeze)

        # Count packages
        pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])
        success(f"Saved snapshot '{name}' ({pkg_count} packages)")

        return 0

    except Exception as e:
        error(f"Failed to save snapshot: {e}")
        return 1


def cmd_restore(args):
    """Restore named snapshot"""
    name = args.name

    if not venv_exists():
        error("User venv not initialized")
        return 1

    snapshot_file = SNAPSHOTS_PATH / f"{name}.txt"

    if not snapshot_file.exists():
        error(f"Snapshot '{name}' not found")
        info("Available snapshots: sysvenv list-snapshots")
        return 1

    freeze = snapshot_file.read_text()
    pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])

    heading(f"Restoring snapshot '{name}' ({pkg_count} packages)")

    if args.dry_run:
        warning("DRY RUN - no changes will be made")
        print("\nWould restore packages:")
        for line in freeze.split('\n'):
            if line.strip():
                print(f"  {line}")
        return 0

    # Confirm restoration
    if not confirm_action(f"This will delete current venv and restore '{name}'. Continue?"):
        info("Cancelled")
        return 0

    # Check disk space
    if not check_disk_space(SYSVENV_ROOT, 500):
        error("Low disk space (need at least 500MB)")
        return 1

    try:
        # Nuke and recreate venv
        info("Removing current venv...")
        shutil.rmtree(VENV_PATH)

        info("Creating fresh venv...")
        venv.create(VENV_PATH, with_pip=True, symlinks=True)

        # Upgrade pip
        pip_bin = VENV_PATH / "bin" / "pip"
        run_command([str(pip_bin), "install", "--upgrade", "pip", "-q"])

        # Restore packages
        if freeze.strip():
            info("Restoring packages...")
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(freeze)
                temp_file = f.name

            try:
                run_command([str(pip_bin), "install", "-r", temp_file, "-q"], capture=False)
            finally:
                os.unlink(temp_file)

        success(f"Restored snapshot '{name}'")
        return 0

    except Exception as e:
        error(f"Restore failed: {e}")
        error("Your venv may be in an inconsistent state. Run 'sysvenv doctor --fix' to repair.")
        return 1


def cmd_list_snapshots(args):
    """List available snapshots"""
    snapshots = sorted(SNAPSHOTS_PATH.glob("*.txt"))

    if not snapshots:
        warning("No snapshots yet")
        return 0

    heading("Available Snapshots")

    for snap in snapshots:
        name = snap.stem
        size = snap.stat().st_size
        mtime = datetime.fromtimestamp(snap.stat().st_mtime)

        # Count packages
        freeze = snap.read_text()
        pkg_count = len([l for l in freeze.split('\n') if l.strip() and not l.startswith('#')])

        print(f"  {name:20s}  {pkg_count:3d} packages  {mtime.strftime('%Y-%m-%d %H:%M')}")

    return 0


# ============================================================================
# Internal commands (used by pip wrapper)
# ============================================================================

def cmd_snapshot_before(args):
    """Internal: Take before snapshot"""
    ensure_dirs()

    entry_id = get_history_id()
    freeze = pip_freeze()

    entry = {
        "id": entry_id,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "user": os.getenv("USER", "unknown"),
        "command": " ".join(args.command),
        "pip_args": args.command,
        "freeze": freeze
    }

    before_file = HISTORY_PATH / f"{entry_id:03d}_before.json"
    with open(before_file, 'w') as f:
        json.dump(entry, f, indent=2)

    return 0


def cmd_snapshot_after(args):
    """Internal: Take after snapshot"""
    # Find the most recent before snapshot
    before_files = sorted(HISTORY_PATH.glob("*_before.json"))
    if not before_files:
        return 0

    before_file = before_files[-1]
    with open(before_file) as f:
        before_entry = json.load(f)

    entry_id = before_entry["id"]
    before_freeze = before_entry["freeze"]
    after_freeze = pip_freeze()

    # Calculate diff
    added, removed, modified = diff_packages(before_freeze, after_freeze)

    after_entry = before_entry.copy()
    after_entry["freeze"] = after_freeze
    after_entry["changes"] = {
        "added": added,
        "removed": removed,
        "modified": modified
    }
    after_entry["exit_code"] = 0

    after_file = HISTORY_PATH / f"{entry_id:03d}_after.json"
    with open(after_file, 'w') as f:
        json.dump(after_entry, f, indent=2)

    # Show diff
    if added or removed or modified:
        heading("Changes:")
        if added:
            for pkg in added:
                cprint(f"  + {pkg}", Colors.GREEN)
        if removed:
            for pkg in removed:
                cprint(f"  - {pkg}", Colors.RED)
        if modified:
            for pkg in modified:
                cprint(f"  ~ {pkg}", Colors.YELLOW)

        info(f"Saved as operation #{entry_id}")

    return 0


# ============================================================================
# CLI Setup
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Two-Tier Python Package System Manager",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    # Global options
    parser.add_argument('-y', '--yes', action='store_true',
                        help='Skip confirmation prompts')

    subparsers = parser.add_subparsers(dest='command', help='Command to run')

    # init
    parser_init = subparsers.add_parser('init', help='Initialize user venv')
    parser_init.set_defaults(func=cmd_init)

    # status
    parser_status = subparsers.add_parser('status', help='Show current status')
    parser_status.set_defaults(func=cmd_status)

    # doctor
    parser_doctor = subparsers.add_parser('doctor', help='Health check and repair')
    parser_doctor.add_argument('--fix', action='store_true', help='Attempt to fix issues')
    parser_doctor.set_defaults(func=cmd_doctor)

    # history
    parser_history = subparsers.add_parser('history', help='Show operation history')
    parser_history.add_argument('--limit', type=int, help='Limit number of entries')
    parser_history.set_defaults(func=cmd_history)

    # diff
    parser_diff = subparsers.add_parser('diff', help='Show changes from operation')
    parser_diff.add_argument('entry_id', type=int, nargs='?', help='Operation ID (default: last)')
    parser_diff.set_defaults(func=cmd_diff)

    # undo
    parser_undo = subparsers.add_parser('undo', help='Undo last N operations')
    parser_undo.add_argument('count', type=int, nargs='?', default=1, help='Number of operations to undo')
    parser_undo.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser_undo.set_defaults(func=cmd_undo)

    # clean
    parser_clean = subparsers.add_parser('clean', help='Nuke and recreate venv')
    parser_clean.add_argument('--keep-baseline', action='store_true', help='Restore baseline after clean')
    parser_clean.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser_clean.set_defaults(func=cmd_clean)

    # snapshot
    parser_snapshot = subparsers.add_parser('snapshot', help='Save named snapshot')
    parser_snapshot.add_argument('name', help='Snapshot name')
    parser_snapshot.add_argument('--force', action='store_true', help='Overwrite existing snapshot')
    parser_snapshot.set_defaults(func=cmd_snapshot)

    # restore
    parser_restore = subparsers.add_parser('restore', help='Restore named snapshot')
    parser_restore.add_argument('name', help='Snapshot name')
    parser_restore.add_argument('--dry-run', action='store_true', help='Show what would be done')
    parser_restore.set_defaults(func=cmd_restore)

    # list-snapshots
    parser_list = subparsers.add_parser('list-snapshots', help='List available snapshots')
    parser_list.set_defaults(func=cmd_list_snapshots)

    # Internal commands (used by pip wrapper)
    parser_sb = subparsers.add_parser('_snapshot-before', help=argparse.SUPPRESS)
    parser_sb.add_argument('command', nargs='+')
    parser_sb.set_defaults(func=cmd_snapshot_before)

    parser_sa = subparsers.add_parser('_snapshot-after', help=argparse.SUPPRESS)
    parser_sa.add_argument('command', nargs='+')
    parser_sa.set_defaults(func=cmd_snapshot_after)

    # Parse and run
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # Set SYSVENV_YES if --yes flag provided
    if getattr(args, 'yes', False):
        os.environ["SYSVENV_YES"] = "1"

    try:
        return args.func(args)
    except KeyboardInterrupt:
        print("\n\nInterrupted")
        return 130
    except Exception as e:
        error(f"Unexpected error: {e}")
        if os.getenv("DEBUG"):
            raise
        return 1


if __name__ == "__main__":
    sys.exit(main())
