#!/bin/bash
#
# pip wrapper - Routes pip to correct venv and handles snapshotting
#
# This wrapper intercepts pip commands and:
# 1. Routes root user to system venv (/opt/system-python/venv)
# 2. Routes regular users to user venv (~/.local/python-packages/venv)
# 3. Takes before/after snapshots for install/uninstall operations
# 4. Respects $VIRTUAL_ENV if already set (project venvs)
#

set -e

# ============================================================================
# Configuration
# ============================================================================

SYSTEM_VENV="/opt/system-python/venv"
USER_VENV="$HOME/.local/python-packages/venv"

# ============================================================================
# Determine target venv
# ============================================================================

# If we're in an activated venv, use that (highest priority)
if [ -n "$VIRTUAL_ENV" ]; then
    TARGET_VENV="$VIRTUAL_ENV"
    USE_WRAPPER=false
# If running as root, use system venv
elif [ "$EUID" -eq 0 ]; then
    TARGET_VENV="$SYSTEM_VENV"
    USE_WRAPPER=false
# Regular user - check for project markers and offer project venv
else
    # Check if we're in a project directory with markers
    PROJECT_MARKERS=(
        "requirements.txt"
        "pyproject.toml"
        "setup.py"
        "poetry.lock"
        "Pipfile"
    )

    HAS_PROJECT_MARKER=false
    for marker in "${PROJECT_MARKERS[@]}"; do
        if [ -f "$marker" ]; then
            HAS_PROJECT_MARKER=true
            break
        fi
    done

    # Check if local venv exists
    if [ -d "./venv" ] || [ -d "./.venv" ]; then
        # Use local venv if it exists
        if [ -d "./venv" ]; then
            LOCAL_VENV="./venv"
        else
            LOCAL_VENV="./.venv"
        fi

        # Warn if not activated
        if [ -z "$VIRTUAL_ENV" ]; then
            echo "âš ï¸  Project venv detected but not activated: $LOCAL_VENV" >&2
            echo "   Activate with: source $LOCAL_VENV/bin/activate" >&2
            echo "   Or: pip will install to user venv instead" >&2
            echo "" >&2
        fi
    # Suggest creating project venv if markers found and this is an install operation
    elif [ "$HAS_PROJECT_MARKER" = true ] && [ "${1:-}" = "install" ]; then
        echo "ðŸ’¡ Project markers detected (requirements.txt, pyproject.toml, etc.)" >&2
        echo "   Consider creating a project venv for isolation:" >&2
        echo "   â†’ python3 -m venv venv && source venv/bin/activate" >&2
        echo "   â†’ Then run your pip install command" >&2
        echo "" >&2
        echo "   Continuing with user venv..." >&2
        echo "" >&2
    fi

    TARGET_VENV="$USER_VENV"
    USE_WRAPPER=true
fi

PIP_BIN="$TARGET_VENV/bin/pip"

# Check if pip exists
if [ ! -f "$PIP_BIN" ]; then
    echo "Error: pip not found at $PIP_BIN" >&2

    if [ "$EUID" -ne 0 ] && [ "$TARGET_VENV" = "$USER_VENV" ]; then
        echo "" >&2
        echo "User venv not initialized. Run:" >&2
        echo "  sysvenv init" >&2
    fi

    exit 1
fi

# ============================================================================
# Snapshot handling for user venv
# ============================================================================

# Check if this is a write operation that should be snapshotted
SNAPSHOT_OPERATIONS="install|uninstall|upgrade"
FIRST_ARG="${1:-}"

SHOULD_SNAPSHOT=false
if [ "$USE_WRAPPER" = true ] && [[ "$FIRST_ARG" =~ ^($SNAPSHOT_OPERATIONS)$ ]]; then
    SHOULD_SNAPSHOT=true
fi

# Take before snapshot and check for conflicts
if [ "$SHOULD_SNAPSHOT" = true ]; then
    # Check if sysvenv exists
    if command -v sysvenv >/dev/null 2>&1; then
        # Check for system package conflicts on install operations
        if [ "$FIRST_ARG" = "install" ]; then
            sysvenv _check-conflicts "$@" 2>/dev/null || true
        fi

        sysvenv _snapshot-before "$@" 2>/dev/null || true
    fi
fi

# ============================================================================
# Run actual pip
# ============================================================================

"$PIP_BIN" "$@"
EXIT_CODE=$?

# ============================================================================
# Take after snapshot
# ============================================================================

if [ "$SHOULD_SNAPSHOT" = true ] && [ $EXIT_CODE -eq 0 ]; then
    if command -v sysvenv >/dev/null 2>&1; then
        sysvenv _snapshot-after "$@" 2>/dev/null || true
    fi
fi

exit $EXIT_CODE
